{"version":3,"file":"immer.js","sources":["../src/patches.js","../src/common.js","../src/proxy.js","../src/es5.js","../src/immer.js"],"sourcesContent":["import {each} from \"./common\"\n\nexport function generatePatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    if (patches)\n        if (Array.isArray(baseValue))\n            generateArrayPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n        else\n            generateObjectPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n}\n\nexport function generateArrayPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    const shared = Math.min(baseValue.length, resultValue.length)\n    for (let i = 0; i < shared; i++) {\n        if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n            const path = basepath.concat(i)\n            patches.push({op: \"replace\", path, value: resultValue[i]})\n            inversePatches.push({op: \"replace\", path, value: baseValue[i]})\n        }\n    }\n    if (shared < resultValue.length) {\n        // stuff was added\n        for (let i = shared; i < resultValue.length; i++) {\n            const path = basepath.concat(i)\n            patches.push({op: \"add\", path, value: resultValue[i]})\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: baseValue.length\n        })\n    } else if (shared < baseValue.length) {\n        // stuff was removed\n        patches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: resultValue.length\n        })\n        for (let i = shared; i < baseValue.length; i++) {\n            const path = basepath.concat(i)\n            inversePatches.push({op: \"add\", path, value: baseValue[i]})\n        }\n    }\n}\n\nfunction generateObjectPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = baseValue[key]\n        const value = resultValue[key]\n        const op = !assignedValue\n            ? \"remove\"\n            : key in baseValue\n                ? \"replace\"\n                : \"add\"\n        if (origValue === baseValue && op === \"replace\") return\n        const path = basepath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                    ? {op: \"add\", path, value: origValue}\n                    : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        const {path} = patch\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            let base = draft\n            for (let i = 0; i < path.length - 1; i++) {\n                base = base[path[i]]\n                if (!base || typeof base !== \"object\")\n                    throw new Error(\n                        \"Cannot apply patch, path doesn't resolve: \" +\n                            path.join(\"/\")\n                    )\n            }\n            const key = path[path.length - 1]\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key === base.length - 1) base.length -= 1\n                        else\n                            throw new Error(\n                                `Remove can only remove the last key of an array, index: ${key}, length: ${\n                                    base.length\n                                }`\n                            )\n                    } else delete base[key]\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import {generatePatches} from \"./patches\"\n\nexport const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nexport function original(value) {\n    if (value && value[PROXY_STATE]) {\n        return value[PROXY_STATE].base\n    }\n    // otherwise return undefined\n}\n\nconst assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base, path, patches, inversePatches) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            const result = finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state,\n                path,\n                patches,\n                inversePatches\n            )\n            generatePatches(\n                state,\n                path,\n                patches,\n                inversePatches,\n                state.base,\n                result\n            )\n            return result\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) {\n            // if there was an assignment on this property, we don't need to generate\n            // patches for the subtree\n            const generatePatches = patches && !has(state.assigned, prop)\n            copy[prop] = finalize(\n                value,\n                generatePatches && path.concat(prop),\n                generatePatches && patches,\n                inversePatches\n            )\n        }\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support deleting properties from arrays: \" + prop\n        )\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support setting non-numeric properties on arrays: \" +\n                prop\n        )\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\nfunction createState(parent, base) {\n    return {\n        modified: false, // this tree is modified (either this object or one of it's children)\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    // TODO: optimize\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    state.assigned[prop] = false\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop)\n            ? state.proxies\n            : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base) {\n    if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\")\n    const state = createState(parentState, base)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const previousProxies = proxies\n    proxies = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n\n            // See #117\n            // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n            // Looks like a wrongly modeled reducer\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    has,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    state.assigned[prop] = true // optimization; skip this if there is no listener\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChangesSweep() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[PROXY_STATE]\n    if (!state) return\n    const {proxy, base} = state\n    if (Array.isArray(object)) {\n        if (hasArrayChanges(state)) {\n            markChanged(state)\n            state.assigned.length = true\n            if (proxy.length < base.length)\n                for (let i = proxy.length; i < base.length; i++)\n                    state.assigned[i] = false\n            else\n                for (let i = base.length; i < proxy.length; i++)\n                    state.assigned[i] = true\n            each(proxy, (index, child) => {\n                if (!state.assigned[index]) markChangesRecursively(child)\n            })\n        }\n    } else {\n        const {added, removed} = diffKeys(base, proxy)\n        if (added.length > 0 || removed.length > 0) markChanged(state)\n        each(added, (_, key) => {\n            state.assigned[key] = true\n        })\n        each(removed, (_, key) => {\n            state.assigned[key] = false\n        })\n        each(proxy, (key, child) => {\n            if (!state.assigned[key]) markChangesRecursively(child)\n        })\n    }\n}\n\nfunction diffKeys(from, to) {\n    // TODO: optimize\n    const a = Object.keys(from)\n    const b = Object.keys(to)\n    return {\n        added: b.filter(key => a.indexOf(key) === -1),\n        removed: a.filter(key => b.indexOf(key) === -1)\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const {base, proxy} = state\n\n    // Search for added keys. Start at the back, because non-numeric keys\n    // are ordered by time of definition on the object.\n    const keys = Object.keys(proxy)\n    for (let i = keys.length; i !== 0; ) {\n        const key = keys[--i]\n\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (base[key] === undefined && !has(base, key)) {\n            return true\n        }\n    }\n\n    // Since no keys have been added, we can compare lengths to know if an\n    // object has been deleted.\n    return keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n    const {proxy} = state\n    if (proxy.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nexport function produceEs5(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const prevStates = states\n    states = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            if (patchListener) markChangesRecursively(rootProxy)\n            markChangesSweep() // this one is more efficient if we don't need to know which attributes have changed\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","export {\n    setAutoFreeze,\n    setUseProxies,\n    original,\n    isProxy as isDraft\n} from \"./common\"\n\nimport {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {isProxyable, getUseProxies, NOTHING} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport function produce(baseState, producer, patchListener) {\n    // prettier-ignore\n    if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length)\n\n    // curried invocation\n    if (typeof baseState === \"function\" && typeof producer !== \"function\") {\n        const initialState = producer\n        const recipe = baseState\n\n        return function(currentState = initialState, ...args) {\n            return produce(currentState, draft =>\n                recipe.call(draft, draft, ...args)\n            )\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n        if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n    }\n\n    // avoid proxying anything except plain objects and arrays\n    if (!isProxyable(baseState)) {\n        const returnValue = producer(baseState)\n        return returnValue === undefined\n            ? baseState\n            : normalizeResult(returnValue)\n    }\n\n    return normalizeResult(\n        getUseProxies()\n            ? produceProxy(baseState, producer, patchListener)\n            : produceEs5(baseState, producer, patchListener)\n    )\n}\n\nfunction normalizeResult(result) {\n    return result === NOTHING ? undefined : result\n}\n\nexport default produce\n\nexport const applyPatches = produce(applyPatchesImpl)\n\nexport const nothing = NOTHING\n"],"names":["generatePatches","state","basepath","patches","inversePatches","baseValue","resultValue","Array","isArray","generateArrayPatches","generateObjectPatches","shared","Math","min","length","i","assigned","path","concat","push","op","value","key","assignedValue","origValue","applyPatches","draft","patch","base","Error","join","NOTHING","Symbol","PROXY_STATE","RETURNED_AND_MODIFIED_ERROR","verifyMinified","inProduction","process","env","NODE_ENV","name","autoFreeze","useProxies","Proxy","Reflect","setAutoFreeze","enableAutoFreeze","setUseProxies","getUseProxies","isProxy","isProxyable","proto","Object","getPrototypeOf","prototype","freeze","original","assign","target","has","shallowCopy","slice","__proto__","undefined","create","each","cb","thing","prop","hasOwnProperty","call","finalize","modified","finalized","copy","result","finalizeObject","finalizeNonProxiedObject","parent","isFrozen","child","is","x","y","proxies","objectTraps","source","ownKeys","arrayTraps","fn","arguments","apply","deleteProperty","isNaN","parseInt","set","createState","get","createProxy","getOwnPropertyDescriptor","owner","descriptor","configurable","defineProperty","markChanged","parentState","proxy","revocable","produceProxy","baseState","producer","patchListener","returnValue","previousProxies","rootProxy","_","p","revoke","descriptors","states","hasCopy","finalizing","prepareCopy","createPropertyProxy","assertUnfinished","finished","JSON","stringify","markChangesSweep","hasArrayChanges","hasObjectChanges","markChangesRecursively","object","index","diffKeys","added","removed","from","to","a","keys","b","filter","indexOf","produceEs5","prevStates","createHiddenProperty","produce","initialState","recipe","args","currentState","normalizeResult","applyPatchesImpl","nothing"],"mappings":"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"}
{"version":3,"file":"immer.umd.js","sources":["../src/patches.js","../src/common.js","../src/proxy.js","../src/es5.js","../src/immer.js"],"sourcesContent":["import {each} from \"./common\"\n\nexport function generatePatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    if (patches)\n        if (Array.isArray(baseValue))\n            generateArrayPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n        else\n            generateObjectPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n}\n\nexport function generateArrayPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    const shared = Math.min(baseValue.length, resultValue.length)\n    for (let i = 0; i < shared; i++) {\n        if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n            const path = basepath.concat(i)\n            patches.push({op: \"replace\", path, value: resultValue[i]})\n            inversePatches.push({op: \"replace\", path, value: baseValue[i]})\n        }\n    }\n    if (shared < resultValue.length) {\n        // stuff was added\n        for (let i = shared; i < resultValue.length; i++) {\n            const path = basepath.concat(i)\n            patches.push({op: \"add\", path, value: resultValue[i]})\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: baseValue.length\n        })\n    } else if (shared < baseValue.length) {\n        // stuff was removed\n        patches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: resultValue.length\n        })\n        for (let i = shared; i < baseValue.length; i++) {\n            const path = basepath.concat(i)\n            inversePatches.push({op: \"add\", path, value: baseValue[i]})\n        }\n    }\n}\n\nfunction generateObjectPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = baseValue[key]\n        const value = resultValue[key]\n        const op = !assignedValue\n            ? \"remove\"\n            : key in baseValue\n                ? \"replace\"\n                : \"add\"\n        if (origValue === baseValue && op === \"replace\") return\n        const path = basepath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                    ? {op: \"add\", path, value: origValue}\n                    : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        const {path} = patch\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            let base = draft\n            for (let i = 0; i < path.length - 1; i++) {\n                base = base[path[i]]\n                if (!base || typeof base !== \"object\")\n                    throw new Error(\n                        \"Cannot apply patch, path doesn't resolve: \" +\n                            path.join(\"/\")\n                    )\n            }\n            const key = path[path.length - 1]\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key === base.length - 1) base.length -= 1\n                        else\n                            throw new Error(\n                                `Remove can only remove the last key of an array, index: ${key}, length: ${\n                                    base.length\n                                }`\n                            )\n                    } else delete base[key]\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import {generatePatches} from \"./patches\"\n\nexport const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nexport function original(value) {\n    if (value && value[PROXY_STATE]) {\n        return value[PROXY_STATE].base\n    }\n    // otherwise return undefined\n}\n\nconst assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base, path, patches, inversePatches) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            const result = finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state,\n                path,\n                patches,\n                inversePatches\n            )\n            generatePatches(\n                state,\n                path,\n                patches,\n                inversePatches,\n                state.base,\n                result\n            )\n            return result\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) {\n            // if there was an assignment on this property, we don't need to generate\n            // patches for the subtree\n            const generatePatches = patches && !has(state.assigned, prop)\n            copy[prop] = finalize(\n                value,\n                generatePatches && path.concat(prop),\n                generatePatches && patches,\n                inversePatches\n            )\n        }\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support deleting properties from arrays: \" + prop\n        )\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support setting non-numeric properties on arrays: \" +\n                prop\n        )\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\nfunction createState(parent, base) {\n    return {\n        modified: false, // this tree is modified (either this object or one of it's children)\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    // TODO: optimize\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    state.assigned[prop] = false\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop)\n            ? state.proxies\n            : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base) {\n    if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\")\n    const state = createState(parentState, base)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const previousProxies = proxies\n    proxies = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n\n            // See #117\n            // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n            // Looks like a wrongly modeled reducer\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    has,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    state.assigned[prop] = true // optimization; skip this if there is no listener\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChangesSweep() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[PROXY_STATE]\n    if (!state) return\n    const {proxy, base} = state\n    if (Array.isArray(object)) {\n        if (hasArrayChanges(state)) {\n            markChanged(state)\n            state.assigned.length = true\n            if (proxy.length < base.length)\n                for (let i = proxy.length; i < base.length; i++)\n                    state.assigned[i] = false\n            else\n                for (let i = base.length; i < proxy.length; i++)\n                    state.assigned[i] = true\n            each(proxy, (index, child) => {\n                if (!state.assigned[index]) markChangesRecursively(child)\n            })\n        }\n    } else {\n        const {added, removed} = diffKeys(base, proxy)\n        if (added.length > 0 || removed.length > 0) markChanged(state)\n        each(added, (_, key) => {\n            state.assigned[key] = true\n        })\n        each(removed, (_, key) => {\n            state.assigned[key] = false\n        })\n        each(proxy, (key, child) => {\n            if (!state.assigned[key]) markChangesRecursively(child)\n        })\n    }\n}\n\nfunction diffKeys(from, to) {\n    // TODO: optimize\n    const a = Object.keys(from)\n    const b = Object.keys(to)\n    return {\n        added: b.filter(key => a.indexOf(key) === -1),\n        removed: a.filter(key => b.indexOf(key) === -1)\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const {base, proxy} = state\n\n    // Search for added keys. Start at the back, because non-numeric keys\n    // are ordered by time of definition on the object.\n    const keys = Object.keys(proxy)\n    for (let i = keys.length; i !== 0; ) {\n        const key = keys[--i]\n\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (base[key] === undefined && !has(base, key)) {\n            return true\n        }\n    }\n\n    // Since no keys have been added, we can compare lengths to know if an\n    // object has been deleted.\n    return keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n    const {proxy} = state\n    if (proxy.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nexport function produceEs5(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const prevStates = states\n    states = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            if (patchListener) markChangesRecursively(rootProxy)\n            markChangesSweep() // this one is more efficient if we don't need to know which attributes have changed\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","export {\n    setAutoFreeze,\n    setUseProxies,\n    original,\n    isProxy as isDraft\n} from \"./common\"\n\nimport {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {isProxyable, getUseProxies, NOTHING} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport function produce(baseState, producer, patchListener) {\n    // prettier-ignore\n    if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length)\n\n    // curried invocation\n    if (typeof baseState === \"function\" && typeof producer !== \"function\") {\n        const initialState = producer\n        const recipe = baseState\n\n        return function(currentState = initialState, ...args) {\n            return produce(currentState, draft =>\n                recipe.call(draft, draft, ...args)\n            )\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n        if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n    }\n\n    // avoid proxying anything except plain objects and arrays\n    if (!isProxyable(baseState)) {\n        const returnValue = producer(baseState)\n        return returnValue === undefined\n            ? baseState\n            : normalizeResult(returnValue)\n    }\n\n    return normalizeResult(\n        getUseProxies()\n            ? produceProxy(baseState, producer, patchListener)\n            : produceEs5(baseState, producer, patchListener)\n    )\n}\n\nfunction normalizeResult(result) {\n    return result === NOTHING ? undefined : result\n}\n\nexport default produce\n\nexport const applyPatches = produce(applyPatchesImpl)\n\nexport const nothing = NOTHING\n"],"names":["generatePatches","state","basepath","patches","inversePatches","baseValue","resultValue","Array","isArray","shared","Math","min","length","i","assigned","path","concat","push","op","value","generateArrayPatches","key","assignedValue","origValue","generateObjectPatches","NOTHING","Symbol","PROXY_STATE","RETURNED_AND_MODIFIED_ERROR","autoFreeze","process","env","NODE_ENV","name","useProxies","Proxy","Reflect","isProxy","isProxyable","proto","Object","getPrototypeOf","prototype","assign","target","has","shallowCopy","slice","undefined","__proto__","create","each","cb","thing","prop","hasOwnProperty","call","finalize","base","modified","finalized","copy","result","freeze","finalizeObject","finalizeNonProxiedObject","parent","isFrozen","child","is","x","y","proxies","objectTraps","createProxy","source","ownKeys","owner","descriptor","getOwnPropertyDescriptor","configurable","Error","arrayTraps","markChanged","parentState","createState","proxy","revocable","fn","arguments","apply","this","deleteProperty","isNaN","parseInt","set","descriptors","states","hasCopy","prepareCopy","defineProperty","finalizing","get","assertUnfinished","finished","JSON","stringify","markChangesRecursively","object","from","to","a","b","hasArrayChanges","index","keys","filter","indexOf","added","removed","_","hasObjectChanges","produceEs5","baseState","producer","patchListener","returnValue","prevStates","rootProxy","produce","initialState","recipe","args","draft","normalizeResult","previousProxies","p","revoke","produceProxy","applyPatches","patch","join","nothing","enableAutoFreeze"],"mappings":"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"}